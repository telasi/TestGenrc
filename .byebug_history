continue
esit
exit
self.serializable_hash(only: fields)
fields
self.stage
continue
aa["id"]
aa=JSON.parse(response.body)
response.body
response
exit
e.message
exit
result
exit
obj.to_hash
obj
result
c
result
c
e.message
c
result['message']
c
result['message']
result[:message]
result
c
e.message
c
result
c
result.key?('error')
result.has_key?('error')
result.has_key?(:error)
result.key?(:error)
result
result && result.key?(:error)
result && result.key?(:result)
c
e.message
c
e.message
c
obj
c
result[:result]
result
c
obj
exit
obj.class::CASE_ID
obj.class
Docflow::CASE_ID
obj.docnumber
obj::CASE_ID
obj.CASE_ID
obj
e.message
c
obj
exit
e.message
c
obj.to_hash
obj.stage
exit
obj.to_hash
obj
exit
classname
exit
e.message
exit
options
self
PHASE1_URL
c
answer = JSON.parse(response.parsed_response)
response
exit
Log.create!(service: classname, service_id: id, action: 'send', success: 0, error: e.message[0..254])
Log.create!(service: classname, service_id: id, action: 'send', success: 0, error: e.message[0..255])
Log.create!(service: classname, service_id: id, action: 'send', success: 0, error: 'a')
e.message
id
classname
Log.create!(service: classname, service_id: id, action: 'send', success: 0, error: e.message)
e.message
exit
answer
answer[:message]
answer = answer.first
answer = ['result':'OK', 'id': 1456]
result["message"] == nil
result = nil
result = 3
result["message"]
result[:message]
result
resault
result = nil
result
case_id.present?
case_id = nil
case_id.present?
case_id = answer.first[:id]
answer.first[:id]
answer and answer.first[:result] == "OK"
answer && answer.first[:result] == "OK"
answer = ['result':'OK', 'id': 1456]
answer && answer.first[:result] == "OK"
answer and answer.first[:result] == "OK"
answer || answer.first[:result] == "OK"
answer
if answer || answer.first[:result] == "OK"
if answer and answer.first[:result] == "OK"
if anser and answer.first[:result] == "OK"
answer.first[:result] == "OK"
answer = nil
answer.first[:result] == "OK"
answer.first[:result]
if answer.first[:result] == "OK"
if answer.first[:result] = "OK"
if answer.first[:result]
answer.first[:result]
answer.first.response_to?
answer.first.response?
answer.first.response_to
answer.first
answer = ['result':'OK', 'id': 1456]
answer
answer = JSON.parse(response.parsed_response)
response
answer = JSON.parse(response.parsed_response)
response
c
d = clazz.find(id).to_hash
clazz.find(id)
id
clazz.find(id)
clazz
exit
object
c
self.to_hash
self
c
e.message
e.methods
e
exit
e
response.success?
rsponse.success?
answer
response
exit
c
self.post(PHASE1_URL, options)
options
self.post
self
self.
self.class
self.class.
self.class.methods.include?(:post)
self.class.methods
self.class.method
self.class
self
self.class.Class
self.class.name
self.class
c
exit
c
Docflow.start(params)
params
c
exit
tel100 = Tel100.create
log = Log.create
exit
tel100 = Tel100.create!(docnumber: params[:docnumber])
exit
tel100.docnumber = "1"
tel100.id = 1
tel100
tel100.save
tel100 = Tel100.new
tel100 = Tel100.create({docnumber: "2"})
tel100 = Tel100.create({})
tel100 = Tel100.create id: 1, docnumber: 2
tel100 = Tel100.create id: 1
tel100 = Tel100.create {id:1}
tel100 = Tel100.create 1 2
tel100 = Tel100.create
tel100 = Tel100.craete
Tel100.create
Tel100.new
tel100.new
Tel100.all
tel100 = Tel100.create!(docnumber: params[:docnumber])
c
params
c
params
c
params
tel100 = Tel100.new(params.to_hash)
params.to_hash
params.keys
params.class
params.type
params[:docnumber]
tel100 = Tel100.new(params.to_hash)
tel100
params.respond_to?(:permit)
tel100.update_attributes(params.to_hash)
tel100.update_attributes(params)
tel100 = Tel100.new
params
params.to_hash
tel100 = Tel100.create!(params.to_hash)
params.to_hash
params.methods
params.
params.methods?
params.permit
tel100 = Tel100.create!(params)
Tel100.create!(params)
tel100 = Tel100.new(attributes: params)
tel100 = Tel100.new({params})
tel100 = Tel100.new(params)
tel100 = Tel100.new
tel100 = Tel100.create(params)
Tel100.create({})
Tel100.create()
Tel100.create
Tel100
Tel100)
Tel100.new(params)
Tel100.create
Tel100.create()
Tel100.create(params)
params.merge!({stage: 1, stage_1_date: Time.now})
params
c
params
c
params
exit
c
